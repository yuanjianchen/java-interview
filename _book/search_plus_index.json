{"./":{"url":"./","title":"前言","keywords":"","body":"Java 笔记 Copyright © 陈建源 2020            页面修订于: 2020-12-24 16:41:29 "},"Java基础/":{"url":"Java基础/","title":"Java基础","keywords":"","body":"本篇主要总结一些 JDK 开发包中一些基础的内容. Copyright © 陈建源 2020            页面修订于: 2020-12-25 14:56:21 "},"Java基础/数组.html":{"url":"Java基础/数组.html","title":"数组","keywords":"","body":"数组是编程语言中最常见的一种数据结构,可以用于储存多个数据,通常可通过数组元素的索引来访问数组元素,包括数组元素赋值和取出数组元素的值. 初识数组 数组也是一种类型,属于引用数据类型. 数组元素的类型是唯一的,一个数组里只能存储一种类型的数据. 数组的长度是固定的,即一个数组一单初始化完成,数组在内存中所占的空间将被固定下来,长度不在发生改变.即使把某个数组的元素清空,其所占的空间依然被保留. 数组的初始化 定义数组变量 Java支持两种语法格式定义数组: type[] arr; type arr[]; 对于这两种定义而言,通常使用第一种格式来定义数组,因为第一种有更好的语义.第二种容易和变量名混淆 初始化 Java 数组只有初始化之后才能使用,所谓的初始化,就是为数组的元素分配内存空间.并为每个数组元素赋初始值. 静态初始化 由程序员显示的指定每个数组原始的初始值.由系统决定数组的长度. 静态初始化的语法格式为: type[] arr = new type[]{item1, item2, item3,...}; type 为数组元素的数据类型, 数组元素类型必须为 type 类型,或者其子类的实例. 除此之外,静态初始化还有如下简化的语法格式: type[] arr = {item1, item2, item3 ...}; 动态初始化 动态初始化只指定数组的长度,由系统为每个元素指定初始值,动态初始化的语法格式如下: type[] arr = new type[length]; 上面的语法中,需要指定一个 int 类型的 length 参数,这个参数指定了数组的长度. 执行动态初始化时,程序员只指定数组的长度,数组元素的初始值由系统按照如下自动分配 数组元素类型是基本类型中的整数类型(byte, short, int, long),则数组元素的值是 0. 数组元素类型是基本类型中的浮点类型(float, double),则数组元素的值是 0.0. 数组元素类型是基本类型中的字符类型(char),则数组元素的值是'\\u0000'. 数组元素的类型是基本类型中的布尔类型(boolean),则数组元素的值是 false. 数组元素的类型是引用类型(类,接口,数组),则数组元素的值是 null; 数组的访问 数组最常用的方法就是访问数组元素,包括对数组元素进行赋值和取出数组元素. 数组元素读取、赋值 int[] arr = {1,2,3}; // 数组取值 通过 arr[index] 访问 int a = arr[0]; // arr 为{1,3,3} arr[1] = 3 如果访问数组元素时指定的索引值小于0,或者大于等于数组的长度,编译程序时不会出现任何错误,但运行时出现异常java.lang.ArrayIndexOutOfBoundsException:N(数组越界异常), N 就是试图访问的数组索引. 数组的遍历 for 循环 int[] arr = new int[5]; // 输出 5 个 0 for(int i = 0; i 上面的代码第一次循环输出 5 个 0,因为 arr 数组执行的是默认初始化,数组元素是 int 类型,系统为 int 类型的数组元素初始化赋值为 0. foreach循环 Java5 之后,Java 提供了一种更简单的循环:foreach循环,这种循环遍历数组和集合更加方便. for (type item : array|collection){ // } 使用foreach循环需要注意: int[] arr = {1, 2, 3, 4, 5}; for (int item: arr){ System.out.println(item); item = 0; System.out.println(item); } System.out.println(arr[0]); 上例程序将输出 1 0 2 0 3 0 4 0 5 0 1 由输出结果可以看出来,在 foreach循环中对数组元素进行赋值,结果导致不能正确的遍历数组元素.同时在循环中为改变的数组元素的值并没有真正改变数组元素,因为在 foreach中循环变量相当于一个临时变量,系统会把数组元素一次赋值给这个临时变量,而这个临时变量并不是数组元素,它只是保存了数组元素的值.因此要注意:如果希望改变数组元素的值,则不能使用这种 foreach 循环. 深入了解数组 JDK 中的 Array 查看 Java源码中的Array类可以发现它是个 final class, 其中方法如下: Array类中基本都是 getXX 和 setXX 方法, 并且全部都为 native 方法.使用 native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用,因此我们可以将数组理解为是由计算机本地方法去实现的类,并不属于 Java. 数组的内存分布 数组是一种引用数据类型,数组的引用变量时存储在栈内存中的,而数组元素是在堆内存中,并且是连续存放的.这是为了能快速存取数组元素，因为只需要移动index（内部计算物理地址：数组起始地址+index * 元素size大小）就可以访问，而这是很快的 O(1)。 在Java 内存模型中,数组对象被存储在堆(heap)内存中;如果引用该数组对象的变量是一个局部变量,那么它被存储在栈(stack)内存中.如下图所示: 如果需要访问上图堆内存中的数组元素,在程序中只能通过 p[index]的形式实现.也就是说,数组引用变量时访问堆内存中数组元素的根本方式. 现有如下代码: // 定义并静态初始化数组 int[] a = {5, 7, 20}; // 定义数组,使用动态初始化 int[] b = new int[4]; System.out.println(\"b 数组的长度为: \" + b.length); // 循环输出 a 数组的元素 for (int i = 0, len = a.length; i 运行上例代码,首先会输出 b 的长度为 4,然后输出 a,b 的各项元素,接着输出 b 的长度为 3.看起来数组的长度是可变的,其实这是一个假象. 上例代码内存分析: 初始化 a,b 数组,在内存中产生了 4 块区域,栈中的引用变量 a,b 以及堆中的实际数组对象. 其中 a 引用的数组对象长度为 3, b 引用的数组长度为 4. 程序执行b = a 操作.系统会将 a 的值赋给 b,即将 a 引用的数组对象的内存地址赋给 b,此时 b 的值为 a 引用的数组对象的内存地址. 从上可以看出,程序执行 b = a 之后,b 之前引用的数组对象长度并没有发生任何改变,而 b 的值变成了 a 引用的数组对象的地址,此时 b 数组的长度即为 a 数组的长度 3. 需要注意的是数组元素的内存空间是连续的，是指 如果数组元素是原始类型，那么数组元素存放的就是原始类型的值，他们是连续存放的 如果数组元素是对象，那么数组元素就是存放引用了，数组元素是连续存放的，而引用的对象可能在另外的地方，与数组元素可能相隔很远，即不连续。 多维数组 Java 提供了支持多维数组的语法,但是从数组底层的运行机制上来看,并不存在多维数组. 多维数组的定语语法为 type[][] arr = new type[length1][length2] length2可动态创建. 二维数组本质就是一位数组中的每个元素都是一个一维数组. 如上length2给出了值,则初始化了一维数组中的每个元素都是一个长度为length2的一维数组.其内存模型为: Copyright © 陈建源 2020            页面修订于: 2020-12-25 15:17:49 "},"Java基础/集合/集合.html":{"url":"Java基础/集合/集合.html","title":"集合","keywords":"","body":"集合主要存放于 java.util 包中，主要有 3 种：Set(集)、List（列表包含 Queue）、Map（映射）。 Collection：Collection 是集合List、Set、Queue最基本的接口。 Iterator：迭代器，可以通过迭代器遍历集合中的元素。 Map：是映射表的基础接口。 集合框架结构 不同集合的特点 List List 是元素有序并且可以重复的集合，主要有ArrayList，LinkedList，Vector 三种实现。 ArrayList、LinkedList、Vector 的区别 ArrayList LinkedList Vector 底层实现 数组 双向链表 数组 同步性及效率 不同步，非线程安全，效率高，支持随机访问 不同步，非线程安全，效率高 同步，线程安全，效率低 特点 查询快，增删慢 查询慢，增删快 查询快，增删慢 默认容量 10 / 10 扩容机制 int newCapacity = oldCapacity + (oldCapacity >> 1)；//1.5 倍 / 2 倍 ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。 LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 总结 ArrayList 和 Vector 基于数组实现，对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。 LinkedList 不会出现扩容的问题，所以比较适合随机位置增、删。但是其基于链表实现，所以在定位时需要线性扫描，效率比较低。 当操作是在一列数据的后面添加数据而不是在前面或中间，并且需要随机地访问其中的元素时，使用ArrayList会提供比较好的性能； 当你的操作是在一列数据的前面或中间添加或删除数据，并且按照顺序访问其中的元素时，就应该使用LinkedList了。 Set Set集合元素无序(存入和取出的顺序不一定一致)，并且没有重复对象。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法。Set的主要实现类：HashSet， TreeSet。 HashSet 哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。 哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情况；下图表示 hashCode 值相同，但 equals 不相同的情况。 HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。 TreeSet TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使 用。在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序。比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 LinkHashSet 对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。 HashSet、TreeSet、LinkedHashSet的区别 HashSet TreeSet LinkedHashSet 底层实现 HashMap 红黑树 LinkedHashMap 重复性 不允许重复 不允许重复 不允许重复 有无序 无序 有序，支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。 有序，以元素插入的顺序来维护集合的链接表 时间复杂度 add()，remove()，contains()方法的时间复杂度是O(1) add()，remove()，contains()方法的时间复杂度是O(logn) LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet，时间复杂度是 O(1)。 同步性 不同步，线程不安全 不同步，线程不安全 不同步，线程不安全 null值 允许null值 不支持null值，会抛出 java.lang.NullPointerException 异常。因为TreeSet应用 compareTo() 方法于各个元素来比较他们，当比较null值时会抛出 NullPointerException异常。 允许null值 比较 equals() compareTo() equals() 总结 HashSet是一个通用功能的Set，而LinkedHashSet 提供元素插入顺序保证，TreeSet是一个SortedSet实现，由Comparator 或者 Comparable指定的元素顺序存储元素。 Map Map 主要实现为 HashMap、TreeMap、LinkedHashMap、ConcurrentHashMap。 HashMap、ConcurrentHashMap、HashTable、TreeMap的区别 TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 ConcurrentHashMap：和 HashMap 一样基于哈希表实现。 HashMap HashTable TreeMap 底层实现 哈希表（数组+链表） 哈希表（数组+链表） 红黑树 同步性 线程不同步 同步 线程不同步 null值 允许 key 和 Vale 是 null，但是只允许一个 key 为 null，且这个元素存放在哈希表 0 角标位置 不允许key、value 是 null value允许为null。 当未实现 Comparator 接口时，key 不可以为null 当实现 Comparator 接口时，若未对 null 情况进行判断，则可能抛 NullPointerException 异常。如果针对null情况实现了，可以存入，但是却不能正常使用get()访问，只能通过遍历去访问。 hash 使用hash(Object key)扰动函数对 key 的 hashCode 进行扰动后作为 hash 值 直接使用 key 的 hashCode() 返回值作为 hash 值 容量 容量为 2^4 且容量一定是 2^n 默认容量是11，不一定是 2^n 扩容 两倍，且哈希桶的下标使用 &运算代替了取模 2倍+1，取哈希桶下标是直接用模运算 Copyright © 陈建源 2020            页面修订于: 2020-12-31 14:23:12 "},"Java基础/集合/ArrayList.html":{"url":"Java基础/集合/ArrayList.html","title":"ArrayList","keywords":"","body":"简介 ArrayList 是 Java 集合框架中 List 接口的一个实现类。底层是数组，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。 ArrayList是Vector的翻版，区别在于ArrayList是线程不安全的，而Vector则是线程安全的。但是Vector是一个较老的集合，具有很多缺点，不建议使用，这里我们就不对其进行分析了。 ArrayList 可以说是我们使用最多的 List 集合，它有以下特点： 它是基于数组实现的List类 可以动态地调整容量 有序的（元素输出顺序与输入顺序一致） 元素可以为 null 不同步，非线程安全，效率高 查询快，增删慢 占用空间更小，对比 LinkedList，不用占用额外空间维护链表结构 继承结构 public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable 可以看到，ArrayList是AbstractList的子类，同时实现了List接口。除此之外，它还实现了三个标识型接口，这几个接口都没有任何方法，仅作为标识表示实现类具备某项功能。RandomAccess表示实现类支持快速随机访问，Cloneable表示实现类支持克隆，具体表现为重写了clone方法，java.io.Serializable则表示支持序列化，如果需要对此过程自定义，可以重写writeObject与readObject方法。 成员变量 // 序列还 private static final long serialVersionUID = 8683452581122892189L; /** * 数组初始默认容量为 10 */ private static final int DEFAULT_CAPACITY = 10; /** * 空集合实例共享的空数组容器 */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * 默认空集合的空数组容器 与 EMPTY_ELEMENTDATA 区分开，便于了解第一次添加元素是容器扩大多少 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * ArrayList 的储存容器，数组长度就是 ArrayList 的容量。任何一个空集合的 elementData 都为 * DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当集合添加第一个元素时，容量会扩展为 DEFAULT_CAPACITY * transient 表示不可被序列化 */ transient Object[] elementData; // non-private to simplify nested class access /** * 集合的大小（数组元素的个数） */ private int size; /** * 数组最大长度。Integer.MAX_VALUE - 8 是因为一些 VM 会在数组保留一些信息头 * 尝试申请更大的空间会抛出OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 构造函数 /** * 根据指定容量创建对象数组 */ public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } /** * 初始化一个空数组。 * 初始化容量为 0，只有添加第一个元素时，才会扩容为 10 */ public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } /** * 造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。 */ public ArrayList(Collection c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray 有可能不返回一个 Object 数组 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } } 以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。 内部类 private class Itr implements Iterator {} private class ListItr extends Itr implements ListIterator {} private class SubList extends AbstractList implements RandomAccess {} static final class ArrayListSpliterator implements Spliterator {} ArrayList有四个内部类，其中的Itr是实现了Iterator接口，同时重写了里面的hasNext()， next()， remove() 等方法；其中的ListItr 继承 Itr，实现了ListIterator接口，同时重写了hasPrevious()， nextIndex()， previousIndex()， previous()， set(E e)， add(E e) 等方法，所以这也可以看出了 Iterator和ListIterator的区别：ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。 核心方法 add /** * 添加指定元素到集合末尾 */ public boolean add(E e) { // 先确保elementData数组的长度足够，size是数组中数据的个数，因为要添加一个元素，所以size+1， // 先判断size+1的这个个数数组能否放得下，在这个方法中去判断数组长度是否够用 ensureCapacityInternal(size + 1); // Increments modCount!! // 在数据中正确的位置上放上元素e，并且size++ elementData[size++] = e; return true; } /** * 在集合指定位置插入元素，同时将当前位置上的元素以及右面的元素右移 */ public void add(int index, E element) { // 索引检查，抛出 IndexOutOfBoundsException rangeCheckForAdd(index); // 先确保elementData数组的长度足够 ensureCapacityInternal(size + 1); // Increments modCount!! // 拷贝数组，指定位置以及之后的元素右移一位, 有效率问题 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } /** * 校验插入位置是否合理 */ private void rangeCheckForAdd(int index) { // 插入的位置肯定不能大于size 和小于0 if (index > size || index c) { // 把该集合转为对象数组 Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount // 将集合 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; } /** * 将指定集合插入到指定位置 */ public boolean addAll(int index, Collection c) { rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount // 计算需要移动的元素个数 int numMoved = size - index; if (numMoved > 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; } private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } //计算容量。判断初始化的elementData是不是空的数组,如果是空的话，返回默认容量10与minCapacity=size+1的较大值者。 private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } private void ensureExplicitCapacity(int minCapacity) { modCount++; // 此处考虑溢出 minCapacity 为 size + 1, 当添加新元素时，如果集合的 size + 1 大于 集合内部数组 elementData 的长度，此时就需要进行扩容。 if (minCapacity - elementData.length > 0) grow(minCapacity); } /** * 集合扩容 */ private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; // 右移一位 扩容 1.5 倍 oldCapacity >> 1 相当于 oldCapacity/2 int newCapacity = oldCapacity + (oldCapacity >> 1); // 扩容 1.5 倍之后容量还不够，则是使用申请容量 if (newCapacity - minCapacity 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } /** * 如果扩容后容量大于数组最大分配容量(Integer.MAX_VALUE - 8) */ private static int hugeCapacity(int minCapacity) { if (minCapacity MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 至此，就分析完了数组的添加方法，以及添加时的扩容机制。可以看出每次扩容以及在指定位置插入元素或集合是都要调用Arrays.copyOf()和System.arraycopy()进行数组间的复制操作。虽然是底层方法，但每次复制也是影响效率的。为了避免频繁扩容，根据空间和时间效率考量，数组扩容都会为 1.5 倍。 了解了扩容机制，当处理大量数据时，为了避免频繁扩容,ArrayList 为我们提供了两种可行方案： 使用ArrayList(int initialCapacity)这个有参构造，在创建时就声明一个较大的大小，这样解决了频繁拷贝问题，但是需要我们提前预知数据的数量级，也会一直占有较大的内存。 除了添加数据时可以自动扩容外，我们还可以在插入前先进行一次扩容。只要提前预知数据的数量级，就可以在需要时直接一次扩充到位，与ArrayList(int initialCapacity)相比的好处在于不必一直占有较大内存，同时数据拷贝的次数也大大减少了。这个方法就是ensureCapacity(int minCapacity)，其内部就是调用了ensureCapacityInternal(int minCapacity)。 使用 ensureCapacity()做一下测试 public class EnsureCapacityTest { public static void main(String[] args) { ArrayList list = new ArrayList(); final int n = 10000000; long startTime = System.currentTimeMillis(); for (int i = 0; i (); long startTime1 = System.currentTimeMillis(); list.ensureCapacity(n); for (int i = 0; i 输出结果为： 使用ensureCapacity方法前：2645 使用ensureCapacity方法后：367 通过运行结果，我们可以很明显的看出向 ArrayList 添加大量元素之前最好先使用ensureCapacity 方法，以减少增量重新分配的次数。 remove 方法 /** * 删除指定位置的元素 */ public E remove(int index) { // 数组范围检查 rangeCheck(index); modCount++; E oldValue = elementData(index); // 要左移的元素的个数 int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将数组最后一个元素置为 null 以便 GC 收集，同时将集合 size 减一 elementData[--size] = null; // clear to let GC do its work // 将删除的元素返回 return oldValue; } /** * 检查数组是否越界 */ private void rangeCheck(int index) { if (index >= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } /** * 从集合中删除第一个要删除的元素 */ public boolean remove(Object o) { // 循环遍历删除 if (o == null) { for (int index = 0; index 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work } /** * 清空集合， 此方法是将数组中的每一个元素值置为 null 并不会使数组长度发生变化 */ public void clear() { modCount++; // clear to let GC do its work for (int i = 0; i c) { Objects.requireNonNull(c); return batchRemove(c, false); } public boolean retainAll(Collection c) { Objects.requireNonNull(c); return batchRemove(c, true); } /** * removeAll 和 retainAll 都调用此批量删除方法 * removeAll 删除当前集合与指定集合的交集 * retainAll 保留当前集合与指定集合的交集 */ private boolean batchRemove(Collection c, boolean complement) { final Object[] elementData = this.elementData; // r用来控制循环，w是记录有多少个交集 int r = 0, w = 0; boolean modified = false; try { // 遍历当前集合 for (; r filter) { Objects.requireNonNull(filter); // 计算需要删除的元素，在过滤方法中出现任何异常都不会改变几个 int removeCount = 0; // 需要删除的个属于 // 记录需要删除元素的位置 final BitSet removeSet = new BitSet(size); // 将 modCount 存为final 临时变量 expectedModCount 防止并发修改 final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount && i 0; if (anyToRemove) { final int newSize = size - removeCount; for (int i=0, j=0; (i remove几个方法都是类似的。删除过程中会出现以下问题： 删除元素时，会将集合内存数组容器中的当前元素置为 null，以便 GC 回收。但是不会改变集合内部数组容器的大小。 根据索引删除指定位置的元素时，会造成数组的复制，频繁删除影响效率。 批量删除/保留指定集合元素时的时间复杂度为 c1.size * c2.size，即为n2。效率很低。 jdk8 新增方法removeIf 会抛出并发异常。 当遇到集合频繁增加删除时需要考虑 ArrayList 是否合适。 get public E get(int index) { // 检查索引是否正确 rangeCheck(index); return elementData(index); } public E get(int index) { rangeCheck(index); return elementData(index); } ArrayList 由于内部是数组，可以根据索引快速访问，所以 ArrayList 通过索引对对象的访问特别快。同时返回的值都经过了向下转型（Object -> E），这些是对我们应用程序屏蔽的小细节。 set public E set(int index, E element) { // 检查索引是否正确 rangeCheck(index); // 替换当前索引位置的元素 E oldValue = elementData(index); elementData[index] = element; return oldValue; } indexOf & lastIndexOf // 从首开始查找数组里面是否存在指定元素 public int indexOf(Object o) { // 查找的元素为空 if (o == null) { // 遍历数组，找到第一个为空的元素，返回下标 for (int i = 0; i = 0; i--) if (elementData[i]==null) return i; } else { for (int i = size-1; i >= 0; i--) if (o.equals(elementData[i])) return i; } return -1; } 说明：从头开始查找与指定元素相等的元素，需要注意的是可以查找null元素，意味着ArrayList中可以存放null元素的。与此函数对应的lastIndexOf，表示从尾部开始查找。 contains //判断是否含有某个元素 public boolean contains(Object o) { return indexOf(o) >= 0; } toArray /** * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 */ public Object[] toArray() { //elementData：要复制的数组；size：要复制的长度 return Arrays.copyOf(elementData, size); } public T[] toArray(T[] a) { //如果只是要把一部分转换成数组 if (a.length size) a[size] = null; return a; } 扩展 关于System.arraycopy()和 Arrays.copyOf()方法阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及add(int index, E element)、E remove(int index)、toArray() 等方法中都用到了该方法！ System.arraycopy // src：源对象 // srcPos：源对象对象的起始位置 // dest：目标对象 // destPost：目标对象的起始位置 // length：从起始位置往后复制的长度。 // 这段的大概意思就是解释这个方法的用法，复制src到dest，复制的位置是从src的srcPost开始，到srcPost+length-1的位置结束，复制到destPost上，从destPost开始到destPost+length-1的位置上 public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 该方法是个 native 方法，由其他语言（c++）实现，将指定源数组中的数组从指定位置开始复制到目标数组的指定位置。 Arrays.copyOf //Arrays的copyOf()方法传回的数组是新的数组对象，改变传回数组中的元素值，不会影响原来的数组。 //copyOf()的第二个自变量指定要建立的新数组长度，如果新数组的长度超过原数组的长度，则保留数组默认值 public static T[] copyOf(T[] original, int newLength) { return (T[]) copyOf(original, newLength, original.getClass()); } /** * @Description 复制指定的数组, 如有必要用 null 截取或填充，以使副本具有指定的长度 * 对于所有在原数组和副本中都有效的索引，这两个数组相同索引处将包含相同的值 * 对于在副本中有效而在原数组无效的所有索引，副本将填充 null，当且仅当指定长度大于原数组的长度时，这些索引存在 * 返回的数组属于 newType 类 * * @param original 要复制的数组 * @param newLength 副本的长度 * @param newType 副本的类 * * @return T 原数组的副本，截取或用 null 填充以获得指定的长度 * @throws NegativeArraySizeException 如果 newLength 为负 * @throws NullPointerException 如果 original 为 null * @throws ArrayStoreException 如果从 original 中复制的元素不属于存储在 newType 类数组中的运行时类型 */ public static T[] copyOf(U[] original, int newLength, Class newType) { @SuppressWarnings(\"unchecked\") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } 两者联系与区别 联系：看两者源代码可以发现copyOf()内部调用了System.arraycopy()方法。 区别： arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置。 copyOf()是系统自动在内部新建一个数组，并返回该数组。 Copyright © 陈建源 2020            页面修订于: 2021-01-02 09:36:58 "},"Java基础/集合/Set.html":{"url":"Java基础/集合/Set.html","title":"Set","keywords":"","body":"Java 笔记 Copyright © 陈建源 2020            页面修订于: 2020-12-24 16:41:29 "},"Java基础/集合/Map.html":{"url":"Java基础/集合/Map.html","title":"Map","keywords":"","body":"Java 笔记 Copyright © 陈建源 2020            页面修订于: 2020-12-24 16:41:29 "},"Java基础/集合/HashMap.html":{"url":"Java基础/集合/HashMap.html","title":"HashMap","keywords":"","body":"Java 笔记 Copyright © 陈建源 2020            页面修订于: 2020-12-24 16:41:29 "},"Java基础/集合/ConcurrentHashMap.html":{"url":"Java基础/集合/ConcurrentHashMap.html","title":"ConcurrentHashMap","keywords":"","body":"Java 笔记 Copyright © 陈建源 2020            页面修订于: 2020-12-24 16:41:29 "}}