{"./":{"url":"./","title":"前言","keywords":"","body":"Java 笔记 Copyright © 陈建源 2020            页面修订于: 2020-12-24 16:41:29 "},"Java基础/":{"url":"Java基础/","title":"Java基础","keywords":"","body":"本篇主要总结一些 JDK 开发包中一些基础的内容. Copyright © 陈建源 2020            页面修订于: 2020-12-25 14:56:21 "},"Java基础/数组.html":{"url":"Java基础/数组.html","title":"数组","keywords":"","body":"数组是编程语言中最常见的一种数据结构,可以用于储存多个数据,通常可通过数组元素的索引来访问数组元素,包括数组元素赋值和取出数组元素的值. 初识数组 数组也是一种类型,属于引用数据类型. 数组元素的类型是唯一的,一个数组里只能存储一种类型的数据. 数组的长度是固定的,即一个数组一单初始化完成,数组在内存中所占的空间将被固定下来,长度不在发生改变.即使把某个数组的元素清空,其所占的空间依然被保留. 数组的初始化 定义数组变量 Java支持两种语法格式定义数组: type[] arr; type arr[]; 对于这两种定义而言,通常使用第一种格式来定义数组,因为第一种有更好的语义.第二种容易和变量名混淆 初始化 Java 数组只有初始化之后才能使用,所谓的初始化,就是为数组的元素分配内存空间.并为每个数组元素赋初始值. 静态初始化 由程序员显示的指定每个数组原始的初始值.由系统决定数组的长度. 静态初始化的语法格式为: type[] arr = new type[]{item1, item2, item3,...}; type 为数组元素的数据类型, 数组元素类型必须为 type 类型,或者其子类的实例. 除此之外,静态初始化还有如下简化的语法格式: type[] arr = {item1, item2, item3 ...}; 动态初始化 动态初始化只指定数组的长度,由系统为每个元素指定初始值,动态初始化的语法格式如下: type[] arr = new type[length]; 上面的语法中,需要指定一个 int 类型的 length 参数,这个参数指定了数组的长度. 执行动态初始化时,程序员只指定数组的长度,数组元素的初始值由系统按照如下自动分配 数组元素类型是基本类型中的整数类型(byte, short, int, long),则数组元素的值是 0. 数组元素类型是基本类型中的浮点类型(float, double),则数组元素的值是 0.0. 数组元素类型是基本类型中的字符类型(char),则数组元素的值是'\\u0000'. 数组元素的类型是基本类型中的布尔类型(boolean),则数组元素的值是 false. 数组元素的类型是引用类型(类,接口,数组),则数组元素的值是 null; 数组的访问 数组最常用的方法就是访问数组元素,包括对数组元素进行赋值和取出数组元素. 数组元素读取、赋值 int[] arr = {1,2,3}; // 数组取值 通过 arr[index] 访问 int a = arr[0]; // arr 为{1,3,3} arr[1] = 3 如果访问数组元素时指定的索引值小于0,或者大于等于数组的长度,编译程序时不会出现任何错误,但运行时出现异常java.lang.ArrayIndexOutOfBoundsException:N(数组越界异常), N 就是试图访问的数组索引. 数组的遍历 for 循环 int[] arr = new int[5]; // 输出 5 个 0 for(int i = 0; i 上面的代码第一次循环输出 5 个 0,因为 arr 数组执行的是默认初始化,数组元素是 int 类型,系统为 int 类型的数组元素初始化赋值为 0. foreach循环 Java5 之后,Java 提供了一种更简单的循环:foreach循环,这种循环遍历数组和集合更加方便. for (type item : array|collection){ // } 使用foreach循环需要注意: int[] arr = {1, 2, 3, 4, 5}; for (int item: arr){ System.out.println(item); item = 0; System.out.println(item); } System.out.println(arr[0]); 上例程序将输出 1 0 2 0 3 0 4 0 5 0 1 由输出结果可以看出来,在 foreach循环中对数组元素进行赋值,结果导致不能正确的遍历数组元素.同时在循环中为改变的数组元素的值并没有真正改变数组元素,因为在 foreach中循环变量相当于一个临时变量,系统会把数组元素一次赋值给这个临时变量,而这个临时变量并不是数组元素,它只是保存了数组元素的值.因此要注意:如果希望改变数组元素的值,则不能使用这种 foreach 循环. 深入了解数组 JDK 中的 Array 查看 Java源码中的Array类可以发现它是个 final class, 其中方法如下: Array类中基本都是 getXX 和 setXX 方法, 并且全部都为 native 方法.使用 native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用,因此我们可以将数组理解为是由计算机本地方法去实现的类,并不属于 Java. 数组的内存分布 数组是一种引用数据类型,数组的引用变量时存储在栈内存中的,而数组元素是在堆内存中,并且是连续存放的.这是为了能快速存取数组元素，因为只需要移动index（内部计算物理地址：数组起始地址+index * 元素size大小）就可以访问，而这是很快的 O(1)。 在Java 内存模型中,数组对象被存储在堆(heap)内存中;如果引用该数组对象的变量是一个局部变量,那么它被存储在栈(stack)内存中.如下图所示: 如果需要访问上图堆内存中的数组元素,在程序中只能通过 p[index]的形式实现.也就是说,数组引用变量时访问堆内存中数组元素的根本方式. 现有如下代码: // 定义并静态初始化数组 int[] a = {5, 7, 20}; // 定义数组,使用动态初始化 int[] b = new int[4]; System.out.println(\"b 数组的长度为: \" + b.length); // 循环输出 a 数组的元素 for (int i = 0, len = a.length; i 运行上例代码,首先会输出 b 的长度为 4,然后输出 a,b 的各项元素,接着输出 b 的长度为 3.看起来数组的长度是可变的,其实这是一个假象. 上例代码内存分析: 初始化 a,b 数组,在内存中产生了 4 块区域,栈中的引用变量 a,b 以及堆中的实际数组对象. 其中 a 引用的数组对象长度为 3, b 引用的数组长度为 4. 程序执行b = a 操作.系统会将 a 的值赋给 b,即将 a 引用的数组对象的内存地址赋给 b,此时 b 的值为 a 引用的数组对象的内存地址. 从上可以看出,程序执行 b = a 之后,b 之前引用的数组对象长度并没有发生任何改变,而 b 的值变成了 a 引用的数组对象的地址,此时 b 数组的长度即为 a 数组的长度 3. 需要注意的是数组元素的内存空间是连续的，是指 如果数组元素是原始类型，那么数组元素存放的就是原始类型的值，他们是连续存放的 如果数组元素是对象，那么数组元素就是存放引用了，数组元素是连续存放的，而引用的对象可能在另外的地方，与数组元素可能相隔很远，即不连续。 多维数组 Java 提供了支持多维数组的语法,但是从数组底层的运行机制上来看,并不存在多维数组. 多维数组的定语语法为 type[][] arr = new type[length1][length2] length2可动态创建. 二维数组本质就是一位数组中的每个元素都是一个一维数组. 如上length2给出了值,则初始化了一维数组中的每个元素都是一个长度为length2的一维数组.其内存模型为: Copyright © 陈建源 2020            页面修订于: 2020-12-25 15:17:49 "},"Java基础/集合/集合.html":{"url":"Java基础/集合/集合.html","title":"集合","keywords":"","body":"集合主要存放于 java.util 包中，主要有 3 种：Set(集)、List（列表包含 Queue）、Map（映射）。 Collection：Collection 是集合List、Set、Queue最基本的接口。 Iterator：迭代器，可以通过迭代器遍历集合中的元素。 Map：是映射表的基础接口。 集合框架结构 不同集合的特点 List List 是元素有序并且可以重复的集合，主要有ArrayList，LinkedList，Vector 三种实现。 ArrayList、LinkedList、Vector 的区别 ArrayList LinkedList Vector 底层实现 数组 双向链表 数组 同步性及效率 不同步，非线程安全，效率高，支持随机访问 不同步，非线程安全，效率高 同步，线程安全，效率低 特点 查询快，增删慢 查询慢，增删快 查询快，增删慢 默认容量 10 / 10 扩容机制 int newCapacity = oldCapacity + (oldCapacity >> 1)；//1.5 倍 / 2 倍 ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。 LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 总结 ArrayList 和 Vector 基于数组实现，对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。 LinkedList 不会出现扩容的问题，所以比较适合随机位置增、删。但是其基于链表实现，所以在定位时需要线性扫描，效率比较低。 当操作是在一列数据的后面添加数据而不是在前面或中间，并且需要随机地访问其中的元素时，使用ArrayList会提供比较好的性能； 当你的操作是在一列数据的前面或中间添加或删除数据，并且按照顺序访问其中的元素时，就应该使用LinkedList了。 Set Set集合元素无序(存入和取出的顺序不一定一致)，并且没有重复对象。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法。Set的主要实现类：HashSet， TreeSet。 HashSet 哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。 哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情况；下图表示 hashCode 值相同，但 equals 不相同的情况。 HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。 TreeSet TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使 用。在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序。比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 LinkHashSet 对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。 HashSet、TreeSet、LinkedHashSet的区别 HashSet TreeSet LinkedHashSet 底层实现 HashMap 红黑树 LinkedHashMap 重复性 不允许重复 不允许重复 不允许重复 有无序 无序 有序，支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。 有序，以元素插入的顺序来维护集合的链接表 时间复杂度 add()，remove()，contains()方法的时间复杂度是O(1) add()，remove()，contains()方法的时间复杂度是O(logn) LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet，时间复杂度是 O(1)。 同步性 不同步，线程不安全 不同步，线程不安全 不同步，线程不安全 null值 允许null值 不支持null值，会抛出 java.lang.NullPointerException 异常。因为TreeSet应用 compareTo() 方法于各个元素来比较他们，当比较null值时会抛出 NullPointerException异常。 允许null值 比较 equals() compareTo() equals() 总结 HashSet是一个通用功能的Set，而LinkedHashSet 提供元素插入顺序保证，TreeSet是一个SortedSet实现，由Comparator 或者 Comparable指定的元素顺序存储元素。 Map Map 主要实现为 HashMap、TreeMap、LinkedHashMap、ConcurrentHashMap。 HashMap、ConcurrentHashMap、HashTable、TreeMap的区别 TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 ConcurrentHashMap：和 HashMap 一样基于哈希表实现。 HashMap HashTable TreeMap 底层实现 哈希表（数组+链表） 哈希表（数组+链表） 红黑树 同步性 线程不同步 同步 线程不同步 null值 允许 key 和 Vale 是 null，但是只允许一个 key 为 null，且这个元素存放在哈希表 0 角标位置 不允许key、value 是 null value允许为null。 当未实现 Comparator 接口时，key 不可以为null 当实现 Comparator 接口时，若未对 null 情况进行判断，则可能抛 NullPointerException 异常。如果针对null情况实现了，可以存入，但是却不能正常使用get()访问，只能通过遍历去访问。 hash 使用hash(Object key)扰动函数对 key 的 hashCode 进行扰动后作为 hash 值 直接使用 key 的 hashCode() 返回值作为 hash 值 容量 容量为 2^4 且容量一定是 2^n 默认容量是11，不一定是 2^n 扩容 两倍，且哈希桶的下标使用 &运算代替了取模 2倍+1，取哈希桶下标是直接用模运算 Copyright © 陈建源 2020            页面修订于: 2021-01-03 08:29:17 "},"Java基础/集合/ArrayList.html":{"url":"Java基础/集合/ArrayList.html","title":"ArrayList","keywords":"","body":"简介 ArrayList 是 Java 集合框架中 List 接口的一个实现类。底层是数组，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。 ArrayList是Vector的翻版，区别在于ArrayList是线程不安全的，而Vector则是线程安全的。但是Vector是一个较老的集合，具有很多缺点，不建议使用，这里我们就不对其进行分析了。 ArrayList 可以说是我们使用最多的 List 集合，它有以下特点： 它是基于数组实现的List类 可以动态地调整容量 有序的（元素输出顺序与输入顺序一致） 元素可以为 null 不同步，非线程安全，效率高 查询快，增删慢 占用空间更小，对比 LinkedList，不用占用额外空间维护链表结构 继承结构 public class ArrayList extends AbstractList implements List, RandomAccess, Cloneable, java.io.Serializable 可以看到，ArrayList是AbstractList的子类，同时实现了List接口。除此之外，它还实现了三个标识型接口，这几个接口都没有任何方法，仅作为标识表示实现类具备某项功能。RandomAccess表示实现类支持快速随机访问，Cloneable表示实现类支持克隆，具体表现为重写了clone方法，java.io.Serializable则表示支持序列化，如果需要对此过程自定义，可以重写writeObject与readObject方法。 成员变量 // 序列还 private static final long serialVersionUID = 8683452581122892189L; /** * 数组初始默认容量为 10 */ private static final int DEFAULT_CAPACITY = 10; /** * 空集合实例共享的空数组容器 */ private static final Object[] EMPTY_ELEMENTDATA = {}; /** * 默认空集合的空数组容器 与 EMPTY_ELEMENTDATA 区分开，便于了解第一次添加元素是容器扩大多少 */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {}; /** * ArrayList 的储存容器，数组长度就是 ArrayList 的容量。任何一个空集合的 elementData 都为 * DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当集合添加第一个元素时，容量会扩展为 DEFAULT_CAPACITY * transient 表示不可被序列化 */ transient Object[] elementData; // non-private to simplify nested class access /** * 集合的大小（数组元素的个数） */ private int size; /** * 数组最大长度。Integer.MAX_VALUE - 8 是因为一些 VM 会在数组保留一些信息头 * 尝试申请更大的空间会抛出OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 构造函数 /** * 根据指定容量创建对象数组 */ public ArrayList(int initialCapacity) { if (initialCapacity > 0) { this.elementData = new Object[initialCapacity]; } else if (initialCapacity == 0) { this.elementData = EMPTY_ELEMENTDATA; } else { throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); } } /** * 初始化一个空数组。 * 初始化容量为 0，只有添加第一个元素时，才会扩容为 10 */ public ArrayList() { this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; } /** * 造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。 */ public ArrayList(Collection c) { elementData = c.toArray(); if ((size = elementData.length) != 0) { // c.toArray 有可能不返回一个 Object 数组 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); } else { // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; } } 以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。 内部类 private class Itr implements Iterator {} private class ListItr extends Itr implements ListIterator {} private class SubList extends AbstractList implements RandomAccess {} static final class ArrayListSpliterator implements Spliterator {} ArrayList有四个内部类，其中的Itr是实现了Iterator接口，同时重写了里面的hasNext()， next()， remove() 等方法；其中的ListItr 继承 Itr，实现了ListIterator接口，同时重写了hasPrevious()， nextIndex()， previousIndex()， previous()， set(E e)， add(E e) 等方法，所以这也可以看出了 Iterator和ListIterator的区别：ListIterator在Iterator的基础上增加了添加对象，修改对象，逆向遍历等方法，这些是Iterator不能实现的。 核心方法 add /** * 添加指定元素到集合末尾 */ public boolean add(E e) { // 先确保elementData数组的长度足够，size是数组中数据的个数，因为要添加一个元素，所以size+1， // 先判断size+1的这个个数数组能否放得下，在这个方法中去判断数组长度是否够用 ensureCapacityInternal(size + 1); // Increments modCount!! // 在数据中正确的位置上放上元素e，并且size++ elementData[size++] = e; return true; } /** * 在集合指定位置插入元素，同时将当前位置上的元素以及右面的元素右移 */ public void add(int index, E element) { // 索引检查，抛出 IndexOutOfBoundsException rangeCheckForAdd(index); // 先确保elementData数组的长度足够 ensureCapacityInternal(size + 1); // Increments modCount!! // 拷贝数组，指定位置以及之后的元素右移一位, 有效率问题 System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; } /** * 校验插入位置是否合理 */ private void rangeCheckForAdd(int index) { // 插入的位置肯定不能大于size 和小于0 if (index > size || index c) { // 把该集合转为对象数组 Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount // 将集合 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; } /** * 将指定集合插入到指定位置 */ public boolean addAll(int index, Collection c) { rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount // 计算需要移动的元素个数 int numMoved = size - index; if (numMoved > 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; } private void ensureCapacityInternal(int minCapacity) { ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); } //计算容量。判断初始化的elementData是不是空的数组,如果是空的话，返回默认容量10与minCapacity=size+1的较大值者。 private static int calculateCapacity(Object[] elementData, int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { return Math.max(DEFAULT_CAPACITY, minCapacity); } return minCapacity; } private void ensureExplicitCapacity(int minCapacity) { modCount++; // 此处考虑溢出 minCapacity 为 size + 1, 当添加新元素时，如果集合的 size + 1 大于 集合内部数组 elementData 的长度，此时就需要进行扩容。 if (minCapacity - elementData.length > 0) grow(minCapacity); } /** * 集合扩容 */ private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; // 右移一位 扩容 1.5 倍 oldCapacity >> 1 相当于 oldCapacity/2 int newCapacity = oldCapacity + (oldCapacity >> 1); // 扩容 1.5 倍之后容量还不够，则是使用申请容量 if (newCapacity - minCapacity 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } /** * 如果扩容后容量大于数组最大分配容量(Integer.MAX_VALUE - 8) */ private static int hugeCapacity(int minCapacity) { if (minCapacity MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; } 至此，就分析完了数组的添加方法，以及添加时的扩容机制。可以看出每次扩容以及在指定位置插入元素或集合是都要调用Arrays.copyOf()和System.arraycopy()进行数组间的复制操作。虽然是底层方法，但每次复制也是影响效率的。为了避免频繁扩容，根据空间和时间效率考量，数组扩容都会为 1.5 倍。 了解了扩容机制，当处理大量数据时，为了避免频繁扩容,ArrayList 为我们提供了两种可行方案： 使用ArrayList(int initialCapacity)这个有参构造，在创建时就声明一个较大的大小，这样解决了频繁拷贝问题，但是需要我们提前预知数据的数量级，也会一直占有较大的内存。 除了添加数据时可以自动扩容外，我们还可以在插入前先进行一次扩容。只要提前预知数据的数量级，就可以在需要时直接一次扩充到位，与ArrayList(int initialCapacity)相比的好处在于不必一直占有较大内存，同时数据拷贝的次数也大大减少了。这个方法就是ensureCapacity(int minCapacity)，其内部就是调用了ensureCapacityInternal(int minCapacity)。 使用 ensureCapacity()做一下测试 public class EnsureCapacityTest { public static void main(String[] args) { ArrayList list = new ArrayList(); final int n = 10000000; long startTime = System.currentTimeMillis(); for (int i = 0; i (); long startTime1 = System.currentTimeMillis(); list.ensureCapacity(n); for (int i = 0; i 输出结果为： 使用ensureCapacity方法前：2645 使用ensureCapacity方法后：367 通过运行结果，我们可以很明显的看出向 ArrayList 添加大量元素之前最好先使用ensureCapacity 方法，以减少增量重新分配的次数。 remove 方法 /** * 删除指定位置的元素 */ public E remove(int index) { // 数组范围检查 rangeCheck(index); modCount++; E oldValue = elementData(index); // 要左移的元素的个数 int numMoved = size - index - 1; if (numMoved > 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将数组最后一个元素置为 null 以便 GC 收集，同时将集合 size 减一 elementData[--size] = null; // clear to let GC do its work // 将删除的元素返回 return oldValue; } /** * 检查数组是否越界 */ private void rangeCheck(int index) { if (index >= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); } /** * 从集合中删除第一个要删除的元素 */ public boolean remove(Object o) { // 循环遍历删除 if (o == null) { for (int index = 0; index 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work } /** * 清空集合， 此方法是将数组中的每一个元素值置为 null 并不会使数组长度发生变化 */ public void clear() { modCount++; // clear to let GC do its work for (int i = 0; i c) { Objects.requireNonNull(c); return batchRemove(c, false); } public boolean retainAll(Collection c) { Objects.requireNonNull(c); return batchRemove(c, true); } /** * removeAll 和 retainAll 都调用此批量删除方法 * removeAll 删除当前集合与指定集合的交集 * retainAll 保留当前集合与指定集合的交集 */ private boolean batchRemove(Collection c, boolean complement) { final Object[] elementData = this.elementData; // r用来控制循环，w是记录有多少个交集 int r = 0, w = 0; boolean modified = false; try { // 遍历当前集合 for (; r filter) { Objects.requireNonNull(filter); // 计算需要删除的元素，在过滤方法中出现任何异常都不会改变几个 int removeCount = 0; // 需要删除的个属于 // 记录需要删除元素的位置 final BitSet removeSet = new BitSet(size); // 将 modCount 存为final 临时变量 expectedModCount 防止并发修改 final int expectedModCount = modCount; final int size = this.size; for (int i=0; modCount == expectedModCount && i 0; if (anyToRemove) { final int newSize = size - removeCount; for (int i=0, j=0; (i remove几个方法都是类似的。删除过程中会出现以下问题： 删除元素时，会将集合内存数组容器中的当前元素置为 null，以便 GC 回收。但是不会改变集合内部数组容器的大小。 根据索引删除指定位置的元素时，会造成数组的复制，频繁删除影响效率。 批量删除/保留指定集合元素时的时间复杂度为 c1.size * c2.size，即为n2。效率很低。 jdk8 新增方法removeIf 会抛出并发异常。 当遇到集合频繁增加删除时需要考虑 ArrayList 是否合适。 get public E get(int index) { // 检查索引是否正确 rangeCheck(index); return elementData(index); } public E get(int index) { rangeCheck(index); return elementData(index); } ArrayList 由于内部是数组，可以根据索引快速访问，所以 ArrayList 通过索引对对象的访问特别快。同时返回的值都经过了向下转型（Object -> E），这些是对我们应用程序屏蔽的小细节。 set public E set(int index, E element) { // 检查索引是否正确 rangeCheck(index); // 替换当前索引位置的元素 E oldValue = elementData(index); elementData[index] = element; return oldValue; } indexOf & lastIndexOf // 从首开始查找数组里面是否存在指定元素 public int indexOf(Object o) { // 查找的元素为空 if (o == null) { // 遍历数组，找到第一个为空的元素，返回下标 for (int i = 0; i = 0; i--) if (elementData[i]==null) return i; } else { for (int i = size-1; i >= 0; i--) if (o.equals(elementData[i])) return i; } return -1; } 说明：从头开始查找与指定元素相等的元素，需要注意的是可以查找null元素，意味着ArrayList中可以存放null元素的。与此函数对应的lastIndexOf，表示从尾部开始查找。 contains //判断是否含有某个元素 public boolean contains(Object o) { return indexOf(o) >= 0; } toArray /** * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 */ public Object[] toArray() { //elementData：要复制的数组；size：要复制的长度 return Arrays.copyOf(elementData, size); } public T[] toArray(T[] a) { //如果只是要把一部分转换成数组 if (a.length size) a[size] = null; return a; } 扩展 关于System.arraycopy()和 Arrays.copyOf()方法阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及add(int index, E element)、E remove(int index)、toArray() 等方法中都用到了该方法！ System.arraycopy // src：源对象 // srcPos：源对象对象的起始位置 // dest：目标对象 // destPost：目标对象的起始位置 // length：从起始位置往后复制的长度。 // 这段的大概意思就是解释这个方法的用法，复制src到dest，复制的位置是从src的srcPost开始，到srcPost+length-1的位置结束，复制到destPost上，从destPost开始到destPost+length-1的位置上 public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 该方法是个 native 方法，由其他语言（c++）实现，将指定源数组中的数组从指定位置开始复制到目标数组的指定位置。 Arrays.copyOf //Arrays的copyOf()方法传回的数组是新的数组对象，改变传回数组中的元素值，不会影响原来的数组。 //copyOf()的第二个自变量指定要建立的新数组长度，如果新数组的长度超过原数组的长度，则保留数组默认值 public static T[] copyOf(T[] original, int newLength) { return (T[]) copyOf(original, newLength, original.getClass()); } /** * @Description 复制指定的数组, 如有必要用 null 截取或填充，以使副本具有指定的长度 * 对于所有在原数组和副本中都有效的索引，这两个数组相同索引处将包含相同的值 * 对于在副本中有效而在原数组无效的所有索引，副本将填充 null，当且仅当指定长度大于原数组的长度时，这些索引存在 * 返回的数组属于 newType 类 * * @param original 要复制的数组 * @param newLength 副本的长度 * @param newType 副本的类 * * @return T 原数组的副本，截取或用 null 填充以获得指定的长度 * @throws NegativeArraySizeException 如果 newLength 为负 * @throws NullPointerException 如果 original 为 null * @throws ArrayStoreException 如果从 original 中复制的元素不属于存储在 newType 类数组中的运行时类型 */ public static T[] copyOf(U[] original, int newLength, Class newType) { @SuppressWarnings(\"unchecked\") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; } 两者联系与区别 联系：看两者源代码可以发现copyOf()内部调用了System.arraycopy()方法。 区别： arraycopy()需要目标数组，将原数组拷贝到你自己定义的数组里，而且可以选择拷贝的起点和长度以及放入新数组中的位置。 copyOf()是系统自动在内部新建一个数组，并返回该数组。 Copyright © 陈建源 2020            页面修订于: 2021-01-02 09:36:58 "},"Java基础/集合/LinkedList.html":{"url":"Java基础/集合/LinkedList.html","title":"LinkedList","keywords":"","body":"概述 LinkedList 是 Java 集合框架中一个重要的实现，其底层采用的双向链表结构。和 ArrayList 一样，LinkedList 也支持空值和重复值。由于 LinkedList 基于链表实现，存储元素过程中，无需像 ArrayList 那样进行扩容。但有得必有失，LinkedList 存储元素的节点需要额外的空间存储前驱和后继的引用。另一方面，LinkedList 在链表头部和尾部插入效率比较高，但在指定位置进行插入时，效率一般。原因是，在指定位置插入需要定位到该位置处的节点，此操作的时间复杂度为O(N)。最后，LinkedList 是非线程安全的集合类，并发环境下，多个线程同时操作 LinkedList，会引发不可预知的错误。 继承体系 LinkedList 的继承体系较为复杂，继承自 AbstractSequentialList，同时又实现了 List 和 Deque 接口。继承体系图如下 LinkedList 继承自 AbstractSequentialList，AbstractSequentialList 提供了一套基于顺序访问的接口。通过继承此类，子类仅需实现部分代码即可拥有完整的一套访问某种序列表（比如链表）的接口。深入源码，AbstractSequentialList 提供的方法基本上都是通过 ListIterator 实现的，比如： public E get(int index) { try { return listIterator(index).next(); } catch (NoSuchElementException exc) { throw new IndexOutOfBoundsException(\"Index: \"+index); } } public void add(int index, E element) { try { listIterator(index).add(element); } catch (NoSuchElementException exc) { throw new IndexOutOfBoundsException(\"Index: \"+index); } } // 留给子类实现 public abstract ListIterator listIterator(int index); 所以只要继承类实现了 listIterator 方法，它不需要再额外实现什么即可使用。对于随机访问集合类一般建议继承 AbstractList 而不是 AbstractSequentialList。LinkedList 和其父类一样，也是基于顺序访问。所以 LinkedList 继承了 AbstractSequentialList，但 LinkedList 并没有直接使用父类的方法，而是重新实现了一套的方法。 另外，LinkedList 还实现了 Deque (double ended queue)，Deque 又继承自 Queue 接口。这样 LinkedList 就具备了队列的功能。比如，我们可以这样使用： Queue queue = new LinkedList<>(); 除此之外，我们基于 LinkedList 还可以实现一些其他的数据结构，比如栈，以此来替换 Java 集合框架中的 Stack 类（该类实现的不好，《Java 编程思想》一书的作者也对此类进行了吐槽）。 成员变量 // 序列号 private static final long serialVersionUID = 876323262645176354L; // 集合大小 transient int size = 0; // 第一个节点的指针 transient Node first; // 最后一个节点的指针 transient Node last; Node类型在内部类中会展示源码。主要有当前对象、前驱节点、后继节点组成。关于 first和next变量有几个特殊的点： first 节点的前驱节点为 null，同时前驱节点为 null 的节点也为first节点。 last 节点的后继节点为null，同时后继节点为 null 的节点也为last节点。 当 LinkedList 只有一个对象时，此对象既为 first 又为 last。 构造方法 // 构造一个空集合 public LinkedList() { } // 构造一个指定集合的 LinkedList public LinkedList(Collection c) { this(); addAll(c); } 内部类 private class ListItr implements ListIterator {} private class DescendingIterator implements Iterator {} static final class LLSpliterator implements Spliterator {} // 双向链表实现主要类 private static class Node { // 当前元素 E item; // 前驱节点 Node next; // 后继节点 Node prev; // 构造函数 Node(Node prev, E element, Node next) { this.item = element; this.next = next; this.prev = prev; } } LinkedList 双向链表主要是通过Node类实现。其成员变量first，last的类型都为Node。 核心方法 LinkedList继承自AbstractList，又实现了Deque。因此同时有List和Queue的方法。这里将分别分析属于List和Queue的操作并给出时间复杂度。 LinkedList有几个linkXxx和unlinkXxx的基础操作，后面实现的属于List的和Queue的几个方法都是基于这几个方法来实现的。 LinkedList 基本方法 我们先分别看看这几个基础方法。除了node()方法外，其他方法的时间复杂度都为O(1) node // 返回指定索引位置的 node 对象 Node node(int index) { // assert isElementIndex(index); // 如果 index > 1)) { Node x = first; for (int i = 0; i x = last; for (int i = size - 1; i > index; i--) x = x.prev; return x; } } linkFirst // 将对象 e 链接为第一个对象 private void linkFirst(E e) { final Node f = first; // 新建 node， 前驱节点为 null 后继节点为 f(first) final Node newNode = new Node<>(null, e, f); // 将 first 引用改为新建节点 first = newNode; if (f == null) // f == null 表示当前 linkedList 为空集合，添加的第一个元素 即为第一个节点又为最后一个节点 last = newNode; else // f 不为空 将 f 前驱节点置为新建节点 f.prev = newNode; size++; // 集合大小 +1 modCount++; } linkLast // 设置最后一个节点 void linkLast(E e) { final Node l = last; // 新建节点 前驱节点为当前 last 节点，后继节点为 null final Node newNode = new Node<>(l, e, null); last = newNode; if (l == null) // last 为 null 说明该集合为空集合 同时将 first 引用到新建节点上 first = newNode; else // last 不为空将 last 的后继节点设置为新建节点 l.next = newNode; size++; // 集合大小 +1 modCount++; } linkBefore // 将 e 插入到节点 succ 前面 void linkBefore(E e, Node succ) { // assert succ != null; // 取出 succ 节点的前驱节点 final Node pred = succ.prev; // 新建节点，前驱节点为 succ 的前驱节点，后继节点为 succ final Node newNode = new Node<>(pred, e, succ); // 将 succ 的前驱节点替换为新建节点 succ.prev = newNode; if (pred == null) // 如果 succ 之前的前驱节点为 null 则说明 succ 为 first 节点，此时 first 节点就应该设置为新建节点 first = newNode; else // succ 不为 first 节点则将 succ 之前的前驱节点 pred 的后继节点设置为新建节点 pred.next = newNode; size++; // 集合大小 +1 modCount++; } unlinkFirst // 删除当前 first 节点 private E unlinkFirst(Node f) { // assert f == first && f != null; // 取出 first 节点的数据对象 final E element = f.item; // 取出 first 节点的后继节点 final Node next = f.next; // 将 first 节点的数据对象以及将 first 节点的后继节点置为 null（当 first 对象不再引用任何对象，并且不被任何对象引用时，GC 会标记回收） f.item = null; f.next = null; // help GC // 将 next 对象设置为 first 对象（之前的 first 对象会被 GC 回收） first = next; if (next == null) // 如果 next 为空说明集合只有一个 first 元素 此时需要将 last 也清空掉 last = null; else next.prev = null; // 如果 next 不为空，next 即为 first 节点，将 next 节点的前驱节点置为 null size--; // 集合大小 -1 modCount++; return element; } unlinkLast // 删除集合最后一个节点 private E unlinkLast(Node l) { // assert l == last && l != null; // 取出last节点的数据对象 final E element = l.item; // 取出 last 节点的前驱节点 final Node prev = l.prev; // 将 last数据对象以及前驱节点设置为 null 便于 GC 回收 l.item = null; l.prev = null; // help GC // 将 prev 节点设置为 last 节点 last = prev; if (prev == null) // prev 为 null 说明 l 节点既为 first 又为 last first = null; // 将 first 也设置为 null else prev.next = null; // 将 prev 后继节点置为 null 删除对 l 节点的引用 size--; // 集合大小 -1 modCount++; return element; } // 删除节点 E unlink(Node x) { // assert x != null; // 取出节点 x 的数据对象，前驱节点prev和后继节点next final E element = x.item; final Node next = x.next; final Node prev = x.prev; // prev == null 则 x 为 first，因此删除 x 将 next 设置为 first if (prev == null) { first = next; } else { // prev 不为 null 将 prev 的后继节点设置为 next prev.next = next; // 删除 x 对 prev 节点的引用 x.prev = null; } // next == null 说明 x 为 last 节点 删除 x 则需要将 prev 设置为 last if (next == null) { last = prev; } else { // 将 next 的前驱节点设置为 prev next.prev = prev; // 删除 x 对 next 节点的引用 x.next = null; } // 将 x 节点的数据对象设置为 null，等待 gc 清理 x x.item = null; size--; // 将集合大小 -1 modCount++; return element; } 整个插入过程其实很简单，如下图示插入过程： 第一步：新建 node，newNode 的 next 设置为 succ，同时将 newNode 的 prev 设置为 succ.prev。 第二步：将 succ 的 prev 设置成 newNode，同时将 succ.prev 的 next 设置成 newNode。 插入的过程包含以上两个核心步骤，和另外一个分支步骤：当 succ 为 first 时，succ.prev 则为 null，newNode 将会被设置成 first。 另外，linkFirst 和 linkLast 方法和此过程核心步骤相同，区别只在于 linkFirst 的 newNode.prev = null 和 linkLast 的 newNode.next = null。此外，linkFirst 和 linkLast 需要考虑当集合为空时，newNode 既为 first 又为 last。 删除方法主要分为三步： 确定要删除的 node x。 将 x.prev.next 设置为 x.next，同时将 x.prev 的引用置为 null。 将 x.next.prev 设置为 x.prev，同时将 x.next 的引用置为 null 在这核心三步外还有两个分支步骤： 修改 x.prev 时需要判断 x 是否为 first，如果 x == first 则需要将 x.next 设置为 first。 修改 x.next 时需要判断 x 是否为 last， 如果 x == last 则需要将 x.prev 设置为 last。 List 方法 add // 添加对象 添加到集合最后面 public boolean add(E e) { // 调用 本身的 linkLast 方法 linkLast(e); return true; } // 在指定位置添加对象 public void add(int index, E element) { // 检查索引 checkPositionIndex(index); // 如果 index == size 说明在集合最后面插入 if (index == size) linkLast(element); else // 在指定节点前插入对象 linkBefore(element, node(index)); } public boolean addAll(Collection c) { return addAll(size, c); } public boolean addAll(int index, Collection c) { // 索引校验 checkPositionIndex(index); // 将集合转换为数组 Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; // 获取 index 处的 pred succ 节点 Node pred, succ; // index == size 说明在集合最后插入 if (index == size) { succ = null; pred = last; } else { succ = node(index); pred = succ.prev; } // 循环 c 集合，将其中元素不断插入到当前集合中 for (Object o : a) { @SuppressWarnings(\"unchecked\") E e = (E) o; Node newNode = new Node<>(pred, e, null); if (pred == null) // pred == null 说明 succ 为first 将新建 node 设置为 first，再次循环 pred 则为上次循环的新建 node first = newNode else // 将新建 node 设置为 pred 节点的 next pred.next = newNode; pred = newNode; // 将 新建 node 设置为 pred ，再次循环插入的对象都将在 pred 后面 } // succ == null 说明是在集合尾部插入 if (succ == null) { last = pred; // 此时的 pred 为最后一个新建节点，需要将 pred 设置为 last } else { pred.next = succ; // 集合中部插入，要讲 pred 的后继节点设置为 succ succ.prev = pred; // 并把 succ 的前驱节点设置为 pred } size += numNew; // 集合大小加上 c 的长度 modCount++; return true; } List 中的 add 方法中单个元素的插入实现方式就是调用了 LinkedList 内部的 linkxx 方法。区别在于批量添加： 第一步：确定 succ 和 pred。 第二步：循环 c 集合，新建 node 逐个添加至链表。 第三步：newNode 添加至链表后，将 newNode 设置为 pred。再次循环添加。 List 的 addAll 主要步骤包含以上核心三步，同时包含两个分支步骤： 在首次添加元素时需要判断 newNode 是否为 first。 在所有元素添加完之后需要判断 newNode 及 pred 是否为 last。 remove // 删除指定对象 public boolean remove(Object o) { if (o == null) { // 如果 o == null 则从 first 开始遍历 当遇到 第一个为空的元素时，将此元素删除。 for (Node x = first; x != null; x = x.next) { if (x.item == null) { unlink(x); return true; } } } else { // 从 first 开始遍历，删除一个满足 o.equals(x.item) 的元素。 for (Node x = first; x != null; x = x.next) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; } // 删除指定索引位置的元素 public E remove(int index) { checkElementIndex(index); // 需要确定 index 索引位置的元素，然后删除。 return unlink(node(index)); } // 继承 Collection 方法，循环调用 Iterator remove 方法删除 效率很低 public boolean removeAll(Collection c) { Objects.requireNonNull(c); boolean modified = false; Iterator it = iterator(); while (it.hasNext()) { if (c.contains(it.next())) { it.remove(); modified = true; } } return modified; } set // 修改元素 public E set(int index, E element) { checkElementIndex(index); // 查询当前索引对应的 node Node x = node(index); // 更新 node.item E oldVal = x.item; x.item = element; // 返回 old value return oldVal; } get public E get(int index) { checkElementIndex(index); // 查询当前索引对应的 node return node(index).item; } Queue部分的方法 add public void addFirst(E e) { linkFirst(e); } public void addLast(E e) { linkLast(e); } // 队列添加方法 public boolean offer(E e) { return add(e); } public boolean offerFirst(E e) { addFirst(e); return true; } public boolean offerLast(E e) { addLast(e); return true; } // 栈添加方法 public void push(E e) { addFirst(e); } 可以看出 queue 中的添加方法提供了多种，但是都是通过调用 LinkedList 本身的 linkxx 来实现的。 remove public E removeFirst() { final Node f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); } public E removeLast() { final Node l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); } public E poll() { final Node f = first; return (f == null) ? null : unlinkFirst(f); } public E pollFirst() { final Node f = first; return (f == null) ? null : unlinkFirst(f); } public E pop() { return removeFirst(); } public boolean removeFirstOccurrence(Object o) { return remove(o); } public boolean removeLastOccurrence(Object o) { if (o == null) { for (Node x = last; x != null; x = x.prev) { if (x.item == null) { unlink(x); return true; } } } else { for (Node x = last; x != null; x = x.prev) { if (o.equals(x.item)) { unlink(x); return true; } } } return false; } get public E peek() { final Node f = first; return (f == null) ? null : f.item; } public E element() { return getFirst(); } public E getFirst() { final Node f = first; if (f == null) throw new NoSuchElementException(); return f.item; } public E getLast() { final Node l = last; if (l == null) throw new NoSuchElementException(); return l.item; } public E peekFirst() { final Node f = first; return (f == null) ? null : f.item; } Queue 的所有方法都是通过已有的 LinkedList 本身的方法实现。其中的区别主要在于队列/栈的语法规范上，以及对于 null 值的处理（返回 null 或者抛出异常）。由于是实现了队列/栈，并没有提供修改方法。 总结 LinkedList 底层采用的双向链表结构，支持 null 值和重复值。 LinkedList 继承实现了 Queue，可以实现队列以及栈的功能。 LinkedList 存储元素的节点需要额外的空间存储前驱和后继的引用，占用空间有所增加。 LinkedList 在链表头部和尾部插入效率比较高，但在指定位置进行插入时，效率一般。 LinkedList 在随机索引访问时效率一版，每次都要从 first/last 进行遍历。 LinkedList 是非线程安全的集合类。 Copyright © 陈建源 2020            页面修订于: 2021-01-02 21:03:17 "}}