{"./":{"url":"./","title":"前言","keywords":"","body":"Java 笔记 Copyright © 陈建源 2020            页面修订于: 2020-12-24 16:41:29 "},"Java基础/":{"url":"Java基础/","title":"Java基础","keywords":"","body":"本篇主要总结一些 JDK 开发包中一些基础的内容. Copyright © 陈建源 2020            页面修订于: 2020-12-25 14:56:21 "},"Java基础/数组.html":{"url":"Java基础/数组.html","title":"数组","keywords":"","body":"数组是编程语言中最常见的一种数据结构,可以用于储存多个数据,通常可通过数组元素的索引来访问数组元素,包括数组元素赋值和取出数组元素的值. 初识数组 数组也是一种类型,属于引用数据类型. 数组元素的类型是唯一的,一个数组里只能存储一种类型的数据. 数组的长度是固定的,即一个数组一单初始化完成,数组在内存中所占的空间将被固定下来,长度不在发生改变.即使把某个数组的元素清空,其所占的空间依然被保留. 数组的初始化 定义数组变量 Java支持两种语法格式定义数组: type[] arr; type arr[]; 对于这两种定义而言,通常使用第一种格式来定义数组,因为第一种有更好的语义.第二种容易和变量名混淆 初始化 Java 数组只有初始化之后才能使用,所谓的初始化,就是为数组的元素分配内存空间.并为每个数组元素赋初始值. 静态初始化 由程序员显示的指定每个数组原始的初始值.由系统决定数组的长度. 静态初始化的语法格式为: type[] arr = new type[]{item1, item2, item3,...}; type 为数组元素的数据类型, 数组元素类型必须为 type 类型,或者其子类的实例. 除此之外,静态初始化还有如下简化的语法格式: type[] arr = {item1, item2, item3 ...}; 动态初始化 动态初始化只指定数组的长度,由系统为每个元素指定初始值,动态初始化的语法格式如下: type[] arr = new type[length]; 上面的语法中,需要指定一个 int 类型的 length 参数,这个参数指定了数组的长度. 执行动态初始化时,程序员只指定数组的长度,数组元素的初始值由系统按照如下自动分配 数组元素类型是基本类型中的整数类型(byte, short, int, long),则数组元素的值是 0. 数组元素类型是基本类型中的浮点类型(float, double),则数组元素的值是 0.0. 数组元素类型是基本类型中的字符类型(char),则数组元素的值是'\\u0000'. 数组元素的类型是基本类型中的布尔类型(boolean),则数组元素的值是 false. 数组元素的类型是引用类型(类,接口,数组),则数组元素的值是 null; 数组的访问 数组最常用的方法就是访问数组元素,包括对数组元素进行赋值和取出数组元素. 数组元素读取、赋值 int[] arr = {1,2,3}; // 数组取值 通过 arr[index] 访问 int a = arr[0]; // arr 为{1,3,3} arr[1] = 3 如果访问数组元素时指定的索引值小于0,或者大于等于数组的长度,编译程序时不会出现任何错误,但运行时出现异常java.lang.ArrayIndexOutOfBoundsException:N(数组越界异常), N 就是试图访问的数组索引. 数组的遍历 for 循环 int[] arr = new int[5]; // 输出 5 个 0 for(int i = 0; i 上面的代码第一次循环输出 5 个 0,因为 arr 数组执行的是默认初始化,数组元素是 int 类型,系统为 int 类型的数组元素初始化赋值为 0. foreach循环 Java5 之后,Java 提供了一种更简单的循环:foreach循环,这种循环遍历数组和集合更加方便. for (type item : array|collection){ // } 使用foreach循环需要注意: int[] arr = {1, 2, 3, 4, 5}; for (int item: arr){ System.out.println(item); item = 0; System.out.println(item); } System.out.println(arr[0]); 上例程序将输出 1 0 2 0 3 0 4 0 5 0 1 由输出结果可以看出来,在 foreach循环中对数组元素进行赋值,结果导致不能正确的遍历数组元素.同时在循环中为改变的数组元素的值并没有真正改变数组元素,因为在 foreach中循环变量相当于一个临时变量,系统会把数组元素一次赋值给这个临时变量,而这个临时变量并不是数组元素,它只是保存了数组元素的值.因此要注意:如果希望改变数组元素的值,则不能使用这种 foreach 循环. 深入了解数组 JDK 中的 Array 查看 Java源码中的Array类可以发现它是个 final class, 其中方法如下: Array类中基本都是 getXX 和 setXX 方法, 并且全部都为 native 方法.使用 native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，并且被编译成了DLL，由java去调用,因此我们可以将数组理解为是由计算机本地方法去实现的类,并不属于 Java. 数组的内存分布 数组是一种引用数据类型,数组的引用变量时存储在栈内存中的,而数组元素是在堆内存中,并且是连续存放的.这是为了能快速存取数组元素，因为只需要移动index（内部计算物理地址：数组起始地址+index * 元素size大小）就可以访问，而这是很快的 O(1)。 在Java 内存模型中,数组对象被存储在堆(heap)内存中;如果引用该数组对象的变量是一个局部变量,那么它被存储在栈(stack)内存中.如下图所示: 如果需要访问上图堆内存中的数组元素,在程序中只能通过 p[index]的形式实现.也就是说,数组引用变量时访问堆内存中数组元素的根本方式. 现有如下代码: // 定义并静态初始化数组 int[] a = {5, 7, 20}; // 定义数组,使用动态初始化 int[] b = new int[4]; System.out.println(\"b 数组的长度为: \" + b.length); // 循环输出 a 数组的元素 for (int i = 0, len = a.length; i 运行上例代码,首先会输出 b 的长度为 4,然后输出 a,b 的各项元素,接着输出 b 的长度为 3.看起来数组的长度是可变的,其实这是一个假象. 上例代码内存分析: 初始化 a,b 数组,在内存中产生了 4 块区域,栈中的引用变量 a,b 以及堆中的实际数组对象. 其中 a 引用的数组对象长度为 3, b 引用的数组长度为 4. 程序执行b = a 操作.系统会将 a 的值赋给 b,即将 a 引用的数组对象的内存地址赋给 b,此时 b 的值为 a 引用的数组对象的内存地址. 从上可以看出,程序执行 b = a 之后,b 之前引用的数组对象长度并没有发生任何改变,而 b 的值变成了 a 引用的数组对象的地址,此时 b 数组的长度即为 a 数组的长度 3. 需要注意的是数组元素的内存空间是连续的，是指 如果数组元素是原始类型，那么数组元素存放的就是原始类型的值，他们是连续存放的 如果数组元素是对象，那么数组元素就是存放引用了，数组元素是连续存放的，而引用的对象可能在另外的地方，与数组元素可能相隔很远，即不连续。 多维数组 Java 提供了支持多维数组的语法,但是从数组底层的运行机制上来看,并不存在多维数组. 多维数组的定语语法为 type[][] arr = new type[length1][length2] length2可动态创建. 二维数组本质就是一位数组中的每个元素都是一个一维数组. 如上length2给出了值,则初始化了一维数组中的每个元素都是一个长度为length2的一维数组.其内存模型为: Copyright © 陈建源 2020            页面修订于: 2020-12-25 15:17:49 "},"Java基础/集合/集合.html":{"url":"Java基础/集合/集合.html","title":"集合","keywords":"","body":"集合主要存放于 java.util 包中，主要有 3 种：Set(集)、List（列表包含 Queue）、Map（映射）。 Collection：Collection 是集合List、Set、Queue最基本的接口。 Iterator：迭代器，可以通过迭代器遍历集合中的元素。 Map：是映射表的基础接口。 集合框架结构 不同集合的特点 List List 是元素有序并且可以重复的集合，主要有ArrayList，LinkedList，Vector 三种实现。 ArrayList、LinkedList、Vector 的区别 ArrayList LinkedList Vector 底层实现 数组 双向链表 数组 同步性及效率 不同步，非线程安全，效率高，支持随机访问 不同步，非线程安全，效率高 同步，线程安全，效率低 特点 查询快，增删慢 查询慢，增删快 查询快，增删慢 默认容量 10 / 10 扩容机制 int newCapacity = oldCapacity + (oldCapacity >> 1)；//1.5 倍 / 2 倍 ArrayList 是最常用的 List 实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要将已经有数组的数据复制到新的存储空间中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。 Vector 与 ArrayList 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 Vector，避免多线程同时写而引起的不一致性，但实现同步需要很高的花费，因此，访问它比访问 ArrayList 慢。 LinkedList 是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了 List 接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。 总结 ArrayList 和 Vector 基于数组实现，对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。 LinkedList 不会出现扩容的问题，所以比较适合随机位置增、删。但是其基于链表实现，所以在定位时需要线性扫描，效率比较低。 当操作是在一列数据的后面添加数据而不是在前面或中间，并且需要随机地访问其中的元素时，使用ArrayList会提供比较好的性能； 当你的操作是在一列数据的前面或中间添加或删除数据，并且按照顺序访问其中的元素时，就应该使用LinkedList了。 Set Set集合元素无序(存入和取出的顺序不一定一致)，并且没有重复对象。对象的相等性本质是对象 hashCode 值（java 是依据对象的内存地址计算出的此序号）判断的，如果想要让两个不同的对象视为相等的，就必须覆盖 Object 的 hashCode 方法和 equals 方法。Set的主要实现类：HashSet， TreeSet。 HashSet 哈希表边存放的是哈希值。HashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得。元素的哈希值是通过元素的hashcode 方法来获取的, HashSet 首先判断两个元素的哈希值，如果哈希值一样，接着会比较equals 方法 如果 equls 结果为 true ，HashSet 就视为同一个元素。如果 equals 为 false 就不是同一个元素。 哈希值相同 equals 为 false 的元素是怎么存储呢,就是在同样的哈希值下顺延（可以认为哈希值相同的元素放在一个哈希桶中）。也就是哈希一样的存一列。如图 1 表示 hashCode 值不相同的情况；下图表示 hashCode 值相同，但 equals 不相同的情况。 HashSet 通过 hashCode 值来确定元素在内存中的位置。一个 hashCode 位置上可以存放多个元素。 TreeSet TreeSet()是使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。 Integer 和 String 对象都可以进行默认的 TreeSet 排序，而自定义类的对象是不可以的，自己定义的类必须实现 Comparable 接口，并且覆写相应的 compareTo()函数，才可以正常使 用。在覆写 compare()函数时，要返回相应的值才能使 TreeSet 按照一定的规则来排序。比较此对象与指定对象的顺序。如果该对象小于、等于或大于指定对象，则分别返回负整数、零或正整数。 LinkHashSet 对于 LinkedHashSet 而言，它继承与 HashSet、又基于 LinkedHashMap 来实现的。LinkedHashSet 底层使用 LinkedHashMap 来保存所有元素，它继承与 HashSet，其所有的方法操作上又与 HashSet 相同，因此 LinkedHashSet 的实现上非常简单，只提供了四个构造方法，并通过传递一个标识参数，调用父类的构造器，底层构造一个 LinkedHashMap 来实现，在相关操作上与父类 HashSet 的操作相同，直接调用父类 HashSet 的方法即可。 HashSet、TreeSet、LinkedHashSet的区别 HashSet TreeSet LinkedHashSet 底层实现 HashMap 红黑树 LinkedHashMap 重复性 不允许重复 不允许重复 不允许重复 有无序 无序 有序，支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。 有序，以元素插入的顺序来维护集合的链接表 时间复杂度 add()，remove()，contains()方法的时间复杂度是O(1) add()，remove()，contains()方法的时间复杂度是O(logn) LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet，时间复杂度是 O(1)。 同步性 不同步，线程不安全 不同步，线程不安全 不同步，线程不安全 null值 允许null值 不支持null值，会抛出 java.lang.NullPointerException 异常。因为TreeSet应用 compareTo() 方法于各个元素来比较他们，当比较null值时会抛出 NullPointerException异常。 允许null值 比较 equals() compareTo() equals() 总结 HashSet是一个通用功能的Set，而LinkedHashSet 提供元素插入顺序保证，TreeSet是一个SortedSet实现，由Comparator 或者 Comparable指定的元素顺序存储元素。 Map Map 主要实现为 HashMap、TreeMap、LinkedHashMap、ConcurrentHashMap。 HashMap、ConcurrentHashMap、HashTable、TreeMap的区别 TreeMap：基于红黑树实现。 HashMap：基于哈希表实现。 HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 ConcurrentHashMap：和 HashMap 一样基于哈希表实现。 HashMap HashTable TreeMap 底层实现 哈希表（数组+链表） 哈希表（数组+链表） 红黑树 同步性 线程不同步 同步 线程不同步 null值 允许 key 和 Vale 是 null，但是只允许一个 key 为 null，且这个元素存放在哈希表 0 角标位置 不允许key、value 是 null value允许为null。 当未实现 Comparator 接口时，key 不可以为null 当实现 Comparator 接口时，若未对 null 情况进行判断，则可能抛 NullPointerException 异常。如果针对null情况实现了，可以存入，但是却不能正常使用get()访问，只能通过遍历去访问。 hash 使用hash(Object key)扰动函数对 key 的 hashCode 进行扰动后作为 hash 值 直接使用 key 的 hashCode() 返回值作为 hash 值 容量 容量为 2^4 且容量一定是 2^n 默认容量是11，不一定是 2^n 扩容 两倍，且哈希桶的下标使用 &运算代替了取模 2倍+1，取哈希桶下标是直接用模运算 Copyright © 陈建源 2020            页面修订于: 2020-12-31 11:49:42 "},"Java基础/集合/List.html":{"url":"Java基础/集合/List.html","title":"List","keywords":"","body":"Java 笔记 Copyright © 陈建源 2020            页面修订于: 2020-12-24 16:41:29 "},"Java基础/集合/Set.html":{"url":"Java基础/集合/Set.html","title":"Set","keywords":"","body":"Java 笔记 Copyright © 陈建源 2020            页面修订于: 2020-12-24 16:41:29 "},"Java基础/集合/Map.html":{"url":"Java基础/集合/Map.html","title":"Map","keywords":"","body":"Java 笔记 Copyright © 陈建源 2020            页面修订于: 2020-12-24 16:41:29 "},"Java基础/集合/HashMap.html":{"url":"Java基础/集合/HashMap.html","title":"HashMap","keywords":"","body":"Java 笔记 Copyright © 陈建源 2020            页面修订于: 2020-12-24 16:41:29 "},"Java基础/集合/ConcurrentHashMap.html":{"url":"Java基础/集合/ConcurrentHashMap.html","title":"ConcurrentHashMap","keywords":"","body":"Java 笔记 Copyright © 陈建源 2020            页面修订于: 2020-12-24 16:41:29 "}}